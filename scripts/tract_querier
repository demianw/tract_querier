#!/usr/bin/env python
from optparse import OptionParser
import os
import sys


def main():
    parser = OptionParser(
        version=0.1,
        usage="usage: %prog -t tractography_file -a atlas_file "
        "-q queries -o result_prefix"
    )
    parser.add_option("-t", "--tractography", dest="tractography_file_name",
                      help="name of the tractography file")
    parser.add_option("-a", "--atlas", dest="atlas_file_name",
                      help="name of the atlas file")
    parser.add_option("-q", "--queries", dest="queries_string",
                      help="query to run")
    parser.add_option('-o', "--output", dest="output_file_name",
                      help="clustering output file prefix")
    parser.add_option('-I',  dest="include",
                      help="folders to include query files")
    parser.add_option(
        '--threshold', dest='threshold', default=2,
        help="Minimum percentage of the tract to be "
        "considered inside of the label default %default %"
    )
    parser.add_option('--length_threshold', dest='length_threshold', default=0,
                      help="Minimum length of the tract to be considered (in mm) "
                      "default %default %"
                      )
    parser.add_option('--query_selection', dest='query_selection', default='',
                      help="Query selection %default %")
    parser.add_option('--interactive', dest='interactive',
                      default=False, action="store_true",
                      help="Interactive prompt"
                      )
    parser.add_option(
        '--bounding_box_affine_transform', dest='bounding_box_affine_transform',
        help="Bounding box to apply to the image affine transform and tracts "
        "to put both in AC-PC coordinate space"
    )
    parser.add_option(
        '--interactive-webdisplay', dest='interactive_web', action='store_true',
        help='Enables interactive display of the results'
    )
    parser.add_option(
        '--interactive-colortable', dest='interactive_colortable', type=str,
        help='Atlas colortable for the webgl viz'
    )
    parser.add_option(
        '--interactive-webdisplay-url', dest='interactive_url',
        help='Server port for the interactive display of the results: default: http://localhost:9999',
    )

    parser.add_option(
        '--interactive-webdisplay-port', dest='interactive_port',
        help='Server port for the interactive display of the results: default $(default)d',
        default=9999
    )

    (options, args) = parser.parse_args()

    if (
        not options.tractography_file_name or
        not options.atlas_file_name or
        not options.queries_string or
        not options.output_file_name
    ):
        parser.error("incorrect number of arguments")

    options.threshold = float(options.threshold)
    options.length_threshold = float(options.length_threshold)

    global np
    global tract_querier

    import numpy as np
    import nibabel

    import tract_querier

    if options.interactive_web:
        kill_server_callback = activate_webserver(options)
        options.interactive = True
    else:
        kill_server_callback = None

    if options.bounding_box_affine_transform:
        bounding_box_affine_transform = np.fromstring(
            options.bounding_box_affine_transform, sep=','
        ).reshape(4, 4)
        print "RAS transform:"
    else:
        bounding_box_affine_transform = np.eye(4)

    print "Loading files"
    if options.include:
        folders = options.include.split(':')
    else:
        folders = []

    default_folder = tract_querier.default_queries_folder
    folders = [os.getcwd()] + folders + [default_folder]
    for folder in folders:
        if not (os.path.exists(folder) and os.path.isdir(folder)):
            parser.error("Error in include folder %s" % folder)

    try:
        if os.path.exists(options.queries_string):
            query_script = file(options.queries_string).read()
            query_filename = options.queries_string
        else:
            found = False
            for folder in folders:
                file_ = os.path.join(folder, options.queries_string)
                if os.path.exists(file_):
                    found = True
                    break
            if found:
                query_script = file(file_).read()
                query_filename = file_
            else:
                query_script = options.queries_string
                query_filename = '<script>'

        query_file_body = tract_querier.queries_preprocess(
            query_script,
            filename=query_filename,
            include_folders=folders
        )

        tract_querier.queries_syntax_check(query_file_body)
    except tract_querier.TractQuerierSyntaxError, e:
        parser.error(e.value)

    labels_nii = nibabel.load(options.atlas_file_name)
    img = labels_nii.get_data()

    tr = tract_querier.tractography.tractography_from_file(
        options.tractography_file_name
    )

    input_split = os.path.splitext(options.tractography_file_name)
    output_split = os.path.splitext(options.output_file_name)
    if len(output_split) > 1:
        options.output_file_name = output_split[0]
        tractography_extension = output_split[1]

    if options.interactive_web is not None and tractography_extension != '.trk':
        print (
            "The web application only works with Trackvis output files"
            " setting the output to Trackvis mode"
        )
        tractography_extension = '.trk'

    if tractography_extension == '.trk':
        if input_split[-1] == '.trk':
            tractography_extra_kwargs = {
                'affine': tr.affine,
                'image_dimensions': tr.image_dims
            }
        else:
            tractography_extra_kwargs = {
                'affine': labels_nii.get_affine(),
                'image_dimensions': img.shape
            }
    else:
        tractography_extra_kwargs = {}

    print "Calculating labels and crossings"
    affine_ijk_2_ras = labels_nii.get_affine()
    tracts = tr.tracts()

    tractography_spatial_indexing = tract_querier.TractographySpatialIndexing(
        tracts, img, affine_ijk_2_ras, options.length_threshold, options.threshold
    )

    if not options.interactive:
        print "Computing queries"
        evaluated_queries = tract_querier.eval_queries(
            query_file_body,
            tractography_spatial_indexing,
        )

        query_names = evaluated_queries.keys()
        if options.query_selection != '':
            selected_queries = set(options.query_selection.lower().split(','))
            query_names = list(set(query_names) & set(selected_queries))

        query_names.sort()

        for query_name in query_names:
            save_query(
                query_name, tr, options, evaluated_queries,
                extension=tractography_extension, extra_kwargs=tractography_extra_kwargs
            )
    else:
        if options.interactive_url is None and options.interactive_web is None:
            def query_save(query_name, query_result):
                return save_query(
                    query_name, tr, options, {query_name: query_result},
                    extension=tractography_extension, extra_kwargs=tractography_extra_kwargs
                )
            query_del = None
        else:
            import urllib
            def query_save(query_name, query_result):
                filename = save_query(
                    query_name, tr, options, {query_name: query_result},
                    extension=tractography_extension, extra_kwargs=tractography_extra_kwargs
                )
                if filename is not None:
                    try:
                        params = urllib.urlencode({
                            'name': query_name,
                            'file': filename,
                            'action': 'add'
                        })
                        f = urllib.urlopen(options.interactive_url, params)
                        f.close()
                    except Exception, e:
                        print "Interactive URL error:", e
                return filename

            def query_del(query_name):
                try:
                    params = urllib.urlencode({
                        'name': query_name,
                        'action': 'remove'
                    })
                    f = urllib.urlopen(options.interactive_url, params)
                    f.close()
                except Exception, e:
                    print "Interactive URL error:", e

        interactive_shell = tract_querier.TractQuerierCmd(
            tractography_spatial_indexing,
            initial_body=query_script,
            save_query_callback=query_save,
            del_query_callback=query_del,
            eof_callback=kill_server_callback,
            include_folders=folders
        )

        interactive_shell.cmdloop()


def save_query(query_name, tractography, options, evaluated_queries, extension='.vtk', extra_kwargs={}):
    tract_numbers = evaluated_queries[query_name]
    print "\tQuery %s: %.6d" % (query_name, len(tract_numbers))
    if tract_numbers:
        filename = options.output_file_name + "_" + query_name + extension
        save_tractography_file(
            filename,
            tractography,
            tract_numbers,
            extra_kwargs=extra_kwargs
        )
        return filename


def save_tractography_file(
    filename, tractography, tract_numbers, extra_kwargs={}
):
    tract_numbers = list(tract_numbers)

    original_tracts = tractography.original_tracts()

    tracts_to_save = [original_tracts[i] for i in tract_numbers]

    if len(tracts_to_save) == 0:
        return

    tracts_data_to_save = {}
    for key, data in tractography.original_tracts_data().items():
        tracts_data_to_save[key] = [data[f] for f in tract_numbers]

    if (
        'ActiveTensors' not in tracts_data_to_save and
        'Tensors_' in tracts_data_to_save
    ):
        tracts_data_to_save['ActiveTensors'] = 'Tensors_'
    if (
        'ActiveVectors' not in tracts_data_to_save and
        'Vectors_' in tracts_data_to_save
    ):
        tracts_data_to_save['ActiveVectors'] = 'Vectors_'

    tract_querier.tractography.tractography_to_file(
        filename,
        tract_querier.tractography.Tractography(
            tracts_to_save,
            tracts_data_to_save
        ),
        **extra_kwargs
    )


def activate_webserver(options):
    import os
    from multiprocessing import Process
    from tract_querier import tornado_server
    from uuid import uuid4
    suffix = str(uuid4()).replace('-', '')
    options.interactive = True

    options.interactive_port = int(options.interactive_port)

    if options.interactive_url is None:
        options.interactive_url = 'http://localhost:%04d/tracts' % options.interactive_port

    print "Starting web server, please direct your browser to http://localhost:%04d" % options.interactive_port

    p = Process(
        target=tornado_server.xtk_server,
        args=(os.path.abspath(options.atlas_file_name),),
        kwargs={
            'colortable': options.interactive_colortable,
            'port': options.interactive_port,
            'files_path': os.getcwd(),
            'suffix': suffix
        }
    )

    p.start()

    def kill_server():
        p.terminate()

    return kill_server


if __name__ == "__main__":
    main()
    sys.exit()
